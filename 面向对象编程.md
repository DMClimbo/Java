#  一、基本概念

面向对象编程：Object-Oriented Programming，简称OOP。是一种通过对象的方式，把现实世界映射到计算机模型的一种编程方法。

基本概念，包括：

- 类
- 实例
- 方法

实现方式，包括：

- 继承
- 多态

Java语言本身提供的机制，包括：

- package
- classpath
- jar



# 二、类与实例

## 2.1 创建类

在Java中，创建一个类，例如，给这个类命名为`Person`，就是定义一个`class`：

```
class Person {
    public String name;
    public int age;
}
```

`public`是用来修饰字段的，它表示这个字段可以被外部访问。

## 2.2 创建实例

 定义了class，只是定义了对象模版，而要根据对象模版创建出真正的对象实例，必须用new操作符。

new操作符可以创建一个实例，然后，我们需要定义一个引用类型的变量来指向这个实例：

```
Person ming = new Person();
```



 **一个Java源文件可以包含多个类的定义，但只能定义一个public类，且public类名必须与文件名一致。如果要定义多个public类，必须拆到多个Java源文件中。**





# 三、面向对象基础

## 3.1 方法

直接把`field`用`public`暴露给外部可能会破坏封装性，直接操作`field`，容易造成逻辑混乱。为了避免外部代码直接去访问`field`，我们可以用`private`修饰`field`，拒绝外部访问：

```
class Person {
    private String name;
    private int age;
}
```

需要使用方法（`method`）来让外部代码可以间接修改`field`：



## 3.2 this变量

在方法内部，可以使用一个隐含的变量`this`，它始终指向当前实例。因此，通过`this.field`就可以访问当前实例的字段。

如果没有命名冲突，可以省略`this`。例如：

```
class Person {
    private String name;

    public String getName() {
        return name; // 相当于this.name
    }
}
```

但是，如果有局部变量和字段重名，那么局部变量优先级更高，就必须加上`this`：

```
class Person {
    private String name;

    public void setName(String name) {
        this.name = name; // 前面的this不可少，少了就变成局部变量name了
    }
}
```



## 3.3 参数

可变参数用`类型...`定义，可变参数相当于数组类型：

```
class Group {
    private String[] names;

    public void setNames(String... names) {
        this.names = names;
    }
}
```

可变参数的意义：

​	如果写成`String[]`类型，调用方需要自己先构造String，而且可以传入null

  而可变参数可以保证无法传入null， 因为传入0个参数时，接受到的实际值是一个空数组而不是null



- 参数绑定

  ```
  public class Main {
      public static void main(String[] args) {
          Person p = new Person();
          String[] fullname = new String[] { "Homer", "Simpson" };
          p.setName(fullname); // 传入fullname数组
          System.out.println(p.getName()); // "Homer Simpson"
          fullname[0] = "Bart"; // fullname数组的第一个元素修改为"Bart"
          System.out.println(p.getName()); // "Homer Simpson"还是"Bart Simpson"?
      }
  }
  
  class Person {
      private String[] name;
  
      public String getName() {
          return this.name[0] + " " + this.name[1];
      }
  
      public void setName(String[] name) {
          this.name = name;
      }
  }
  
  ```

  **引用类型参数的传递，调用方的变量，和接收方的参数变量**，**指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方（因为指向同一个对象嘛）。**





## 3.4 构造方法

构造方法的名称就是类名。构造方法的参数没有限制，在方法内部，也可以编写任意语句。但是，和普通方法相比，构造方法没有返回值（也没有`void`），调用构造方法，必须用`new`操作符。

- 默认构造方法：如果一个类没有定义构造方法，编译器会自动为我们生成一个默认构造方法，它没有参数，也没有执行语句，类似这样：

  ```
  class Person {
      public Person() {
      }
  }
  ```

  如果我们自定义了一个构造方法，那么**，编译器就*不再*自动创建默认构造方法**：

  ```
  public class Main {
      public static void main(String[] args) {
          Person p = new Person(); // 编译错误:找不到这个构造方法
      }
  }
  
  class Person {
      private String name;
      private int age;
  
      public Person(String name, int age) {
          this.name = name;
          this.age = age;
      }
      
      public String getName() {
          return this.name;
      }
  
      public int getAge() {
          return this.age;
      }
  }
  
  ```

  如果既要能使用带参数的构造方法，又想保留不带参数的构造方法，那么只能把两个构造方法都定义出来

  没有在构造方法中初始化字段时，**引用类型的字段默认是`null`，数值类型的字段用默认值，`int`类型默认值是`0`，布尔类型默认值是`false`**

  在Java中，创建对象实例的时候，按照如下顺序进行初始化：

  1. **先初始化字段，例如，`int age = 10;`表示字段初始化为`10`，`double salary;`表示字段默认初始化为`0`，`String name;`表示引用类型字段默认初始化为`null`；**
  2. **执行构造方法的代码进行初始化。**

  因此，构造方法的代码由于后运行，所以，`new Person("Xiao Ming", 12)`的字段值最终由构造方法的代码确定。

  ```
  class Person {
      private String name = "Unamed";
      private int age = 10;
  
      public Person(String name, int age) {
          this.name = name;
          this.age = age;
      }
  }
  ```

- 多级构造方法

  可以定义多个构造方法，在通过`new`操作符调用的时候，编译器通过构造方法的参数数量、位置和类型自动区分：

  ```
  class Person {
      private String name;
      private int age;
  
      public Person(String name, int age) {
          this.name = name;
          this.age = age;
      }
  
      public Person(String name) {
          this.name = name;
          this.age = 12;
      }
  
      public Person() {
      }
  }
  ```

  **一个构造方法可以调用其他构造方法**，这样做的目的是便于代码复用。调用其他构造方法的语法是`this(…)`

  ```
  class Person {
      private String name;
      private int age;
  
      public Person(String name, int age) {
          this.name = name;
          this.age = age;
      }
  
      public Person(String name) {
          this(name, 18); // 调用另一个构造方法Person(String, int)
      }
  
      public Person() {
          this("Unnamed"); // 调用另一个构造方法Person(String)
      }
  }
  ```

## 3.5 方法重载

方法名相同，但各自的参数不同，称为方法重载（`Overload`），注意：**方法重载的返回值类型通常都是相同的。**

方法重载的目的是，功能类似的方法使用同一名字，更容易记住，因此，调用起来更简单。例如，`String`类提供了多个重载方法`indexOf()`，可以查找子串：

- `int indexOf(int ch)`：根据字符的Unicode码查找；
- `int indexOf(String str)`：根据字符串查找；
- `int indexOf(int ch, int fromIndex)`：根据字符查找，但指定起始位置；
- `int indexOf(String str, int fromIndex)`根据字符串查找，但指定起始位置。



## 3.6 继承

Java使用`extends`关键字来实现继承：

```
class Person {
    private String name;
    private int age;

    public String getName() {...}
    public void setName(String name) {...}
    public int getAge() {...}
    public void setAge(int age) {...}
}

class Student extends Person {
    // 不要重复name和age字段/方法,
    // 只需要定义新增score字段/方法:
    private int score;

    public int getScore() { … }
    public void setScore(int score) { … }
}
```

**子类自动获得了父类的所有字段，严禁定义与父类重名的字段！**

在OOP的术语中，我们把`Person`称为**超类（super class），父类（parent class），基类（base class）**，把`Student`称为**子类（subclass），扩展类（extended class**）。

- 继承树

  在Java中，**没有明确写`extends`的类，编译器会自动加上`extends Object`**。所以，任何类，除了`Object`，都会继承自某个类。下图是`Person`、`Student`的继承树：

  ```ascii
  ┌───────────┐
  │  Object   │
  └───────────┘
        ▲
        │
  ┌───────────┐
  │  Person   │
  └───────────┘
        ▲
        │
  ┌───────────┐
  │  Student  │
  └───────────┘
  ```

  Java只允许一个class继承自一个类，因此，一个类有且仅有一个父类。只有`Object`特殊，它没有父类。

- protected

  继承有个特点，就是子类无法访问父类的`private`字段或者`private`方法。例如，`Student`类就无法访问`Person`类的`name`和`age`字段：

  这使得继承的作用被削弱了。为了让子类可以访问父类的字段，我们需要把`private`改为`protected`。用`protected`修饰的字段可以被子类访问：

- super

  `super`关键字表示父类（超类）。子类引用父类的字段时，可以用`super.fieldName`。例如：

  ```
  class Student extends Person {
      public String hello() {
          return "Hello, " + super.name;
      }
  }
  ```

  实际上，这里使用`super.name`，或者`this.name`，或者`name`，效果都是一样的。编译器会自动定位到父类的`name`字段。

  但是，在某些时候，就必须使用`super`

  ```
  public class Main {
      public static void main(String[] args) {
          Student s = new Student("Xiao Ming", 12, 89);
      }
  }
  
  class Person {
      protected String name;
      protected int age;
  
      public Person(String name, int age) {
          this.name = name;
          this.age = age;
      }
  }
  
  class Student extends Person {
      protected int score;
  
      public Student(String name, int age, int score) {
          this.score = score;
      }
  }
  
  ```

  运行上面的代码，会得到一个编译错误，大意是在`Student`的构造方法中，无法调用`Person`的构造方法。

  **这是因为在Java中，任何`class`的构造方法，第一行语句必须是调用父类的构造方法**。如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句`super();`，所以，`Student`类的构造方法实际上是这样：

  ```
  class Student extends Person {
      protected int score;
  
      public Student(String name, int age, int score) {
          super(); // 自动调用父类的构造方法
          this.score = score;
      }
  }
  ```

  但是，`Person`类并没有无参数的构造方法，因此，编译失败。

  解决方法是调用`Person`类存在的某个构造方法。例如：

  ```
  class Student extends Person {
      protected int score;
  
      public Student(String name, int age, int score) {
          super(name, age); // 调用父类的构造方法Person(String, int)
          this.score = score;
      }
  }
  ```

  **如果父类没有默认的构造方法，子类就必须显式调用`super()`并给出参数以便让编译器定位到父类的一个合适的构造方法**。

  **子类*不会继承*任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。**

  - 阻止继承

    正常情况下，只要某个class没有`final`修饰符，那么任何类都可以从该class继承。

    从Java 15开始，允许使用`sealed`修饰class，并通过`permits`明确写出能够从该class继承的子类名称。

    ```
    public sealed class Shape permits Rect, Circle, Triangle {
        ...
    }
    ```

  - 向上转型

    如果一个引用变量的类型是`Student`，那么它可以指向一个`Student`类型的实例：

    ```
    Student s = new Student();
    ```

    如果一个引用类型的变量是`Person`，那么它可以指向一个`Person`类型的实例：

    ```
    Person p = new Person();
    ```

    一个引用类型为`Person`的变量，能否指向`Student`类型的实例

    ```
    Person p = new Student(); 
    ```

    这是因为`Student`继承自`Person`，因此，它拥有`Person`的全部功能。`Person`类型的变量，如果指向`Student`类型的实例，对它进行操作，是没有问题的！

    这种把一个子类类型安全地变为父类类型的赋值，被称为向上转型（upcasting）。

    向上转型实际上是把一个子类型安全地变为更加抽象的父类型：

    ```
    Student s = new Student();
    Person p = s; // upcasting, ok
    Object o1 = p; // upcasting, ok
    Object o2 = s; // upcasting, ok
    ```

  - 向下转型

    和向上转型相反，如果把一个**父类类型强制转型为子类类型**，就是向下转型（downcasting）。例如：

    ```
    Person p1 = new Student(); // upcasting, ok
    Person p2 = new Person();
    Student s1 = (Student) p1; // ok
    Student s2 = (Student) p2; // runtime error! ClassCastException!
    ```

    `Person`类型`p1`实际指向`Student`实例，`Person`类型变量`p2`实际指向`Person`实例。在向下转型的时候，把`p1`转型为`Student`会成功，因为`p1`确实指向`Student`实例，把`p2`转型为`Student`会失败，因为`p2`的实际类型是`Person`，不能把父类变为子类，因为子类功能比父类多，多的功能无法凭空变出来。

    向下转型很可能会失败。失败的时候，Java虚拟机会报`ClassCastException`。

    为了避免向下转型出错，Java提供了`instanceof`操作符，可以先判断一个实例究竟是不是某种类型：

    ```
    Person p = new Person();
    System.out.println(p instanceof Person); // true
    System.out.println(p instanceof Student); // false
    
    Student s = new Student();
    System.out.println(s instanceof Person); // true
    System.out.println(s instanceof Student); // true
    
    Student n = null;
    System.out.println(n instanceof Student); // false
    ```



## 3.7 多态

在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为覆写（Override）。

在`Person`类中，我们定义了`run()`方法：

```
class Person {
    public void run() {
        System.out.println("Person.run");
    }
}
```

在子类`Student`中，覆写这个`run()`方法：

```
class Student extends Person {
    @Override
    public void run() {
        System.out.println("Student.run");
    }
}
```

Override和Overload不同的是，**如果方法签名不同，就是Overload**，Overload方法是一个新方法；如**果方法签名相同，并且返回值也相同，就是`Override`**。

**方法名相同，方法参数相同，但方法返回值不同，也是不同的方法。在Java程序中，出现这种情况，编译器会报错。**

加上`@Override`可以让编译器帮助检查是否进行了正确的覆写。希望进行覆写，但是不小心写错了方法签名，编译器会报错。



一个实际类型为`Student`，引用类型为`Person`的变量，调用其`run()`方法，**调用的是`Student`的`run()`方法**

Java的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型。

**多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法**。例如：

```
Person p = new Student();
p.run(); // 无法确定运行时究竟调用哪个run()方法
```

多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。

- 覆写Object方法

  因为所有的`class`最终都继承自`Object`，而`Object`定义了几个重要的方法：

  - `toString()`：把instance输出为`String`；
  - `equals()`：判断两个instance是否逻辑相等；
  - `hashCode()`：计算一个instance的哈希值。

  在必要的情况下，我们可以覆写`Object`的这几个方法

  ```
  class Person {
      ...
      // 显示更有意义的字符串:
      @Override
      public String toString() {
          return "Person:name=" + name;
      }
  
      // 比较是否相等:
      @Override
      public boolean equals(Object o) {
          // 当且仅当o为Person类型:
          if (o instanceof Person) {
              Person p = (Person) o;
              // 并且name字段相同时，返回true:
              return this.name.equals(p.name);
          }
          return false;
      }
  
      // 计算hash:
      @Override
      public int hashCode() {
          return this.name.hashCode();
      }
  }
  ```

  在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过`super`来调用。

  ```
  class Person {
      protected String name;
      public String hello() {
          return "Hello, " + name;
      }
  }
  
  class Student extends Person {
      @Override
      public String hello() {
          // 调用父类的hello()方法:
          return super.hello() + "!";
      }
  }
  ```

- final

  继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为`final`。用`final`修饰的方法不能被`Override`：

  ```
  class Person {
      protected String name;
      public final String hello() {
          return "Hello, " + name;
      }
  }
  
  class Student extends Person {
      // compile error: 不允许覆写
      @Override
      public String hello() {
      }
  }
  ```

  如果一个类不希望任何其他类继承自它，那么可以把这个类本身标记为`final`。用`final`修饰的类不能被继承：

  ```
  final class Person {
      protected String name;
  }
  
  // compile error: 不允许继承自Person
  class Student extends Person {
  }
  ```

  对于一个类的实例字段，同样可以用`final`修饰。用`final`修饰的字段在初始化后不能被修改。例如：

  ```
  class Person {
      public final String name = "Unamed";
  }
  ```
  
  可以在构造方法中初始化final字段：
  
  ```
  class Person {
      public final String name;
      public Person(String name) {
          this.name = name;
      }
  }
  ```
  
  这种方法更为常用，因为可以保证实例一旦创建，其`final`字段就不可修改。

## 3.8 抽象类

如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法：

```
class Person {
    public abstract void run();
}
```

如果一个`class`定义了方法，但没有具体执行代码，这个方法就是抽象方法，抽象方法用`abstract`修饰。

因为无法执行抽象方法，因此这个类也必须申明为抽象类（abstract class）。

使用`abstract`修饰的类就是抽象类。我们无法实例化一个抽象类：

```
Person p = new Person(); // 编译错误
```

因为抽象类本身被设计成只能用于被继承，因此，**抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错**。因此，抽象方法实际上相当于定义了“规范”。

- 面向抽象编程

  当我们定义了抽象类`Person`，以及具体的`Student`、`Teacher`子类的时候，我们可以通过抽象类`Person`类型去引用具体的子类的实例：

  ```
  Person s = new Student();
  Person t = new Teacher();
  ```

  这种引用抽象类的好处在于，我们对其进行方法调用，并不关心`Person`类型变量的具体子类型：

  ```
  // 不关心Person变量的具体子类型:
  s.run();
  t.run();
  ```

  同样的代码，如果引用的是一个新的子类，我们仍然不关心具体类型：

  ```
  // 同样不关心新的子类是如何实现run()方法的：
  Person e = new Employee();
  e.run();
  ```

  这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。

  面向抽象编程的本质就是：

  - 上层代码只定义规范（例如：`abstract class Person`）；
  - 不需要子类就可以实现业务逻辑（正常编译）；
  - 具体的业务逻辑由不同的子类实现，调用者并不关心。

## 3.9 接口

在抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力。

如果一个抽象类没有字段，所有方法全部都是抽象方法：

```
abstract class Person {
    public abstract void run();
    public abstract String getName();
}
```

就可以把该抽象类改写为接口：`interface`

在Java中，使用`interface`可以声明一个接口：

```
interface Person {
    void run();
    String getName();
}
```

所谓`interface`，**就是比抽象类还要抽象的纯抽象接口**，因为它连字段都不能有。因为接口定义的所有方法默认都是`public abstract`的，所以这两个修饰符不需要写出来（写不写效果都一样）。

当一个具体的`class`去实现一个`interface`时，需要使用`implements`关键字

```
class Student implements Person {
    private String name;

    public Student(String name) {
        this.name = name;
    }

    @Override
    public void run() {
        System.out.println(this.name + " run");
    }

    @Override
    public String getName() {
        return this.name;
    }
}
```

在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个`interface`

```
class Student implements Person, Hello { // 实现了两个interface
    ...
}
```

抽象类和接口的对比如下：

|            | abstract class       | interface                   |
| :--------- | :------------------- | :-------------------------- |
| 继承       | 只能extends一个class | 可以implements多个interface |
| 字段       | 可以定义实例字段     | 不能定义实例字段            |
| 抽象方法   | 可以定义抽象方法     | 可以定义抽象方法            |
| 非抽象方法 | 可以定义非抽象方法   | 可以定义default方法         |

一个`interface`可以继承自另一个`interface`。`interface`继承自`interface`使用`extends`，它相当于扩展了接口的方法。例如：

```
interface Hello {
    void hello();
}

interface Person extends Hello {
    void run();
    String getName();
```

## 3.10 静态方法

用`static`修饰的字段，称为静态字段

实例字段在每个实例中都有自己的一个独立“空间”，但是静态字段只有一个共享“空间”，**所有实例都会共享该字段**

不推荐用`实例变量.静态字段`去访问静态字段，因为在Java程序中，实例对象并没有静态字段。在代码中，实例对象能访问静态字段只是因为编译器可以根据实例类型自动转换为`类名.静态字段`来访问静态对象。

- 静态方法

  因为静态方法属于`class`而不属于实例，因此，静态方法内部，无法访问`this`变量，也无法访问实例字段，它只能访问静态字段。

  静态方法经常用于工具类，如

  - Arrays.sort()
  - Math.random()

  静态方法也经常用于辅助方法。注意到Java程序的入口`main()`也是静态方法。

- 接口的静态字段

  因为`interface`是一个纯抽象类，所以它不能定义实例字段。但是，`interface`是可以有静态字段的，并且静态字段必须为`final`类型：

  ```
  public interface Person {
      public static final int MALE = 1;
      public static final int FEMALE = 2;
  }
  ```

  实际上，因为`interface`的字段只能是`public static final`类型，所以我们可以把这些修饰符都去掉，上述代码可以简写为：

  ```
  public interface Person {
      // 编译器会自动加上public static final:
      int MALE = 1;
      int FEMALE = 2;
  }
  ```

## 3.11 包

Java定义了一种名字空间，称之为包：`package`。一个类总是属于某个包，类名（比如`Person`）只是一个简写，真正的完整类名是`包名.类名`。

**在定义`class`的时候，我们需要在第一行声明这个`class`属于哪个包。**

```
package ming; // 申明包名ming

public class Person {
}
```

**包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。**

没有定义包名的`class`，它使用的是默认包，非常容易引起名字冲突，因此，不推荐不写包名的做法。

我们还需要按照包结构把上面的Java文件组织起来。假设以`package_sample`作为根目录，`src`作为源码目录，那么所有文件结构就是：

```ascii
package_sample
└─ src
    ├─ hong
    │  └─ Person.java
    │  ming
    │  └─ Person.java
    └─ mr
       └─ jun
          └─ Arrays.java
```

编译后的`.class`文件也需要按照包结构存放。如果使用IDE，把编译后的`.class`文件放到`bin`目录下，那么，编译的文件结构就是：

```ascii
package_sample
└─ bin
   ├─ hong
   │  └─ Person.class
   │  ming
   │  └─ Person.class
   └─ mr
      └─ jun
         └─ Arrays.class
```

可以通过`import `导包，使用`*`表示把这个包下面所有的class都导入进来（但不包括子包的class）

还有一种`import static`的语法，它可以导入一个类的静态字段和静态方法：

```
package main;

// 导入System类的所有静态字段和静态方法:
import static java.lang.System.*;

public class Main {
    public static void main(String[] args) {
        // 相当于调用System.out.println(…)
        out.println("Hello, world!");
    }
}
```

如果有两个`class`名称相同，例如，`mr.jun.Arrays`和`java.util.Arrays`，那么只能`import`其中一个，另一个必须写完整类名

### 编译和运行

假设我们创建了如下的目录结构：

```ascii
work
├── bin
└── src
    └── com
        └── itranswarp
            ├── sample
            │   └── Main.java
            └── world
                └── Person.java
```

其中，`bin`目录用于存放编译后的`class`文件，`src`目录按包结构存放Java源码，我们怎么一次性编译这些Java源码呢？

首先，确保当前目录是`work`目录，即存放`src`和`bin`的父目录：

```
$ ls
bin src
```

然后，编译`src`目录下的所有Java文件：

```
$ javac -d ./bin src/**/*.java
```

命令行`-d`指定输出的`class`文件存放`bin`目录，后面的参数`src/**/*.java`表示`src`目录下的所有`.java`文件，包括任意深度的子目录。

Windows不支持`**`这种搜索全部子目录的做法，所以在Windows下编译必须依次列出所有`.java`文件：

```
C:\work> javac -d bin src\com\itranswarp\sample\Main.java src\com\itranswarp\world\Persion.java
```



## 3.12 作用域

- public

  定义为`public`的`class`、`interface`可以被其他任何类访问

- private

  定义为`private`的`field`、`method`无法被其他类访问

  确切地说，`private`访问权限被限定在`class`的内部，而且与方法声明顺序*无关*。推荐把`private`方法放到后面，因为`public`方法定义了类对外提供的功能，阅读代码的时候，应该先关注`public`方法

  由于Java支持嵌套类，如果一个类内部还定义了嵌套类，那么，**嵌套类拥有访问`private`的权限**

  ```
  public class Main {
      public static void main(String[] args) {
          Inner i = new Inner();
          i.hi();
      }
  
      // private方法:
      private static void hello() {
          System.out.println("private hello!");
      }
  
      // 静态内部类:
      static class Inner {
          public void hi() {
              Main.hello();
          }
      }
  }
  ```

- protected

  `protected`作用于继承关系。定义为`protected`的字段和方法可以被子类访问，以及子类的子类

- package

  包作用域是指一个类允许访问同一个`package`的没有`public`、`private`修饰的`class`，以及没有`public`、`protected`、`private`修饰的字段和方法。

  **包名必须完全一致，包没有父子关系，`com.apache`和`com.apache.abc`是不同的包**。

- 最佳实践

  如果不确定是否需要`public`，就不声明为`public`，即尽可能少地暴露对外的字段和方法。

  把方法定义为`package`权限有助于测试，因为测试类和被测试类只要位于同一个`package`，测试代码就可以访问被测试类的`package`权限方法。

  **一个`.java`文件只能包含一个`public`类，但可以包含多个非`public`类。如果有`public`类，文件名必须和`public`类的名字相同**

## 3.13 内部类

如果一个类定义在另一个类的内部，这个类就是Inner Class：

```
class Outer {
    class Inner {
        // 定义了一个Inner Class
    }
}
```

它与普通类有个最大的不同，就是Inner Class的实例不能单独存在，必须依附于一个Outer Class的实例

```
public class Main {
    public static void main(String[] args) {
        Outer outer = new Outer("Nested"); // 实例化一个Outer
        Outer.Inner inner = outer.new Inner(); // 实例化一个Inner
        inner.hello();
    }
}

class Outer {
    private String name;

    Outer(String name) {
        this.name = name;
    }

    class Inner {
        void hello() {
            System.out.println("Hello, " + Outer.this.name);
        }
    }
}
```

观察上述代码，要实例化一个`Inner`，我们必须首先创建一个`Outer`的实例，然后，调用`Outer`实例的`new`来创建`Inner`实例：

```
Outer.Inner inner = outer.new Inner();
```

这是因为Inner Class除了有一个`this`指向它自己，还隐含地持有一个Outer Class实例，可以用`Outer.this`访问这个实例。所以，实例化一个Inner Class不能脱离Outer实例。

观察上述代码，要实例化一个`Inner`，我们必须首先创建一个`Outer`的实例，然后，调用`Outer`实例的`new`来创建`Inner`实例：

```
Outer.Inner inner = outer.new Inner();
```

这是因为Inner Class除了有一个`this`指向它自己，还隐含地持有一个Outer Class实例，可以用`Outer.this`访问这个实例。所以，实例化一个Inner Class不能脱离Outer实例。

## 3.14 classpath和jar

`classpath`是JVM用到的一个环境变量，它用来指示JVM如何搜索`class`

因为Java是编译型语言，源码文件是`.java`，而编译后的`.class`文件才是真正可以被JVM执行的字节码。因此，JVM需要知道，如果要加载一个`abc.xyz.Hello`的类，应该去哪搜索对应的`Hello.class`文件。

所以，`classpath`就是一组目录的集合，它设置的搜索路径与操作系统相关。例如，在Windows系统上，用`;`分隔，带空格的目录用`""`括起来，可能长这样：

```
C:\work\project1\bin;C:\shared;"D:\My Documents\project1\bin"
```

在Linux系统上，用`:`分隔，可能长这样：

```
/usr/shared:/usr/local/bin:/home/liaoxuefeng/bin
```

`classpath`的设定方法有两种：

在系统环境变量中设置`classpath`环境变量，不推荐；

在启动JVM时设置`classpath`变量，推荐。

强烈*不推荐*在系统环境变量中设置`classpath`，那样会污染整个系统环境。在启动JVM时设置`classpath`才是推荐的做法。实际上就是给`java`命令传入`-classpath`或`-cp`参数：

```
java -classpath .;C:\work\project1\bin;C:\shared abc.xyz.Hello
```

或者使用`-cp`的简写：

```
java -cp .;C:\work\project1\bin;C:\shared abc.xyz.Hello
```

没有设置系统环境变量，也没有传入`-cp`参数，那么JVM默认的`classpath`为`.`，即当前目录：

```
java abc.xyz.Hello
```

更好的做法是，不要设置`classpath`！默认的当前目录`.`对于绝大多数情况都够用了。

- jar包

  如果有很多`.class`文件，散落在各层目录中，肯定不便于管理。如果能把目录打一个包，变成一个文件，就方便多了。

  jar包就是用来干这个事的，它可以把`package`组织的目录层级，以及各个目录下的所有文件（包括`.class`文件和其他文件）都打成一个jar文件，这样一来，无论是备份，还是发给客户，就简单多了。

  jar包实际上就是一个zip格式的压缩文件，而jar包相当于目录。如果我们要执行一个jar包的`class`，就可以把jar包放到`classpath`中：

  ```
  java -cp ./hello.jar abc.xyz.Hello
  ```

  这样JVM会自动在`hello.jar`文件里去搜索某个类。

  **因为jar包就是zip包**，所以，直接在资源管理器中，找到正确的目录，点击右键，在弹出的快捷菜单中选择“发送到”，“压缩(zipped)文件夹”，就制作了一个zip文件。然后，把后缀从`.zip`改为`.jar`，一个jar包就创建成功。

  jar包还可以包含一个特殊的`/META-INF/MANIFEST.MF`文件，`MANIFEST.MF`是纯文本，可以指定`Main-Class`和其它信息。JVM会自动读取这个`MANIFEST.MF`文件，如果存在`Main-Class`，我们就不必在命令行指定启动的类名，而是用更方便的命令：

  ```
  java -jar hello.jar
  ```

  在大型项目中，不可能手动编写`MANIFEST.MF`文件，再手动创建zip包。Java社区提供了大量的开源构建工具，例如[Maven](https://www.liaoxuefeng.com/wiki/1252599548343744/1255945359327200)，可以非常方便地创建jar包。

## 3.15 class版本

我们通常说的Java 8，Java 11，Java 17，是指JDK的版本，也就是JVM的版本，更确切地说，就是`java.exe`这个程序的版本

而每个版本的JVM，它能执行的class文件版本也不同。例如，Java 11对应的class文件版本是55，而Java 17对应的class文件版本是61。

如果用Java 11编译一个Java程序，输出的class文件版本默认就是55，这个class既可以在Java 11上运行，也可以在Java 17上运行，因为Java 17支持的class文件版本是61，表示“最多支持到版本61”。

如果用Java 17编译一个Java程序，输出的class文件版本默认就是61，它可以在Java 17、Java 18上运行，但不可能在Java 11上运行，因为Java 11支持的class版本最多到55。如果使用低于Java 17的JVM运行，会得到一个`UnsupportedClassVersionError`

我们也可以用Java 17编译一个Java程序，指定输出的class版本要兼容Java 11（即class版本55），这样编译生成的class文件就可以在Java >=11的环境中运行。

指定编译输出有两种方式，一种是在`javac`命令行中用参数`--release`设置：

```
$ javac --release 11 Main.java
```

参数`--release 11`表示源码兼容Java 11，编译的class输出版本为Java 11兼容，即class版本55。

第二种方式是用参数`--source`指定源码版本，用参数`--target`指定输出class版本：

```
$ javac --source 9 --target 11 Main.java
```

上述命令如果使用Java 17的JDK编译，它会把源码视为Java 9兼容版本，并输出class为Java 11兼容版本。注意`--release`参数和`--source --target`参数只能二选一，不能同时设置。

用低于Java 11的JVM运行`Hello`会得到一个`LinkageError`，因为无法加载`Hello.class`文件，而用Java 11运行`Hello`会得到一个`NoSuchMethodError`，因为`String.indent()`方法是从Java 12才添加进来的，Java 11的`String`版本根本没有`indent()`方法。

 注：如果使用--release 11则会在编译时检查该方法是否在Java 11中存在。

- 源码版本

  在编写源代码的时候，我们通常会预设一个源码的版本。在编译的时候，如果用`--source`或`--release`指定源码版本，则使用指定的源码版本检查语法。

  例如，使用了lambda表达式的源码版本至少要为8才能编译，使用了`var`关键字的源码版本至少要为10才能编译，使用`switch`表达式的源码版本至少要为12才能编译，且12和13版本需要启用`--enable-preview`参数。

## 3.16 模块

从Java 9开始，JDK又引入了模块（Module）

`.class`文件是JVM看到的最小可执行文件，而一个大型程序需要编写很多Class，并生成一堆`.class`文件，很不便于管理，所以，`jar`文件就是`class`文件的容器。

jar只是用于存放class的容器，它并不关心class之间的依赖。

从Java 9开始引入的模块，主要是为了解决“依赖”这个问题。如果`a.jar`必须依赖另一个`b.jar`才能运行，那我们应该给`a.jar`加点说明啥的，让程序在编译和运行的时候能自动定位到`b.jar`，这种自带“依赖关系”的class容器就是模块。

原有的Java标准库已经由一个单一巨大的`rt.jar`分拆成了几十个模块，这些模块以`.jmod`扩展名标识，可以在`$JAVA_HOME/jmods`目录下找到它们：

- java.base.jmod
- java.compiler.jmod
- java.datatransfer.jmod
- java.desktop.jmod
- ...

这些`.jmod`文件每一个都是一个模块，模块名就是文件名。例如：模块`java.base`对应的文件就是`java.base.jmod`。模块之间的依赖关系已经被写入到模块内的`module-info.class`文件了。所有的模块都直接或间接地依赖`java.base`模块，只有`java.base`模块不依赖任何模块，它可以被看作是“根模块”，好比所有的类都是从`Object`直接或间接继承而来。

把一堆class封装为jar仅仅是一个打包的过程，而把一堆class封装为模块则不但需要打包，还需要写入依赖关系，并且还可以包含二进制代码（通常是JNI扩展）。此外，模块支持多版本，即在同一个模块中可以为不同的JVM提供不同的版本。

### 编写模块

首先，创建模块和原有的创建Java项目是完全一样的，以`oop-module`工程为例，它的目录结构如下：

```ascii
oop-module
├── bin
├── build.sh
└── src
    ├── com
    │   └── itranswarp
    │       └── sample
    │           ├── Greeting.java
    │           └── Main.java
    └── module-info.java
```

其中，`bin`目录存放编译后的class文件，`src`目录存放源码，按包名的目录结构存放，仅仅在`src`目录下多了一个`module-info.java`这个文件，这就是模块的描述文件。在这个模块中，它长这样：

```
module hello.world {
	requires java.base; // 可不写，任何模块都会自动引入java.base
	requires java.xml;
}
```

其中，`module`是关键字，后面的`hello.world`是模块的名称，它的命名规范与包一致。花括号的`requires xxx;`表示这个模块需要引用的其他模块名。除了`java.base`可以被自动引入外，这里我们引入了一个`java.xml`的模块。

当我们使用模块声明了依赖关系后，才能使用引入的模块。例如，`Main.java`代码如下：

```
package com.itranswarp.sample;

// 必须引入java.xml模块后才能使用其中的类:
import javax.xml.XMLConstants;

public class Main {
	public static void main(String[] args) {
		Greeting g = new Greeting();
		System.out.println(g.hello(XMLConstants.XML_NS_PREFIX));
	}
}
```

如果把`requires java.xml;`从`module-info.java`中去掉，编译将报错。可见，模块的重要作用就是声明依赖关系。

使用JDK自带的`jmod`命令把一个jar包转换成模块：

```bash
$ jmod create --class-path hello.jar hello.jmod
```

- 运行模块

  ```bash
  $ java --module-path hello.jmod --module hello.world
  ```

- 打包JRE

  为了支持模块化，Java 9首先带头把自己的一个巨大无比的`rt.jar`拆成了几十个`.jmod`模块，原因就是，运行Java程序的时候，实际上我们用到的JDK模块，并没有那么多。不需要的模块，完全可以删除。

  过去发布一个Java应用程序，要运行它，必须下载一个完整的JRE，再运行jar包。而完整的JRE块头很大，有100多M。怎么给JRE瘦身呢？

  现在，JRE自身的标准库已经分拆成了模块，只需要带上程序用到的模块，其他的模块就可以被裁剪掉。怎么裁剪JRE呢？并不是说把系统安装的JRE给删掉部分模块，而是“复制”一份JRE，但只带上用到的模块。为此，JDK提供了`jlink`命令来干这件事。命令如下：

  ```bash
  $ jlink --module-path hello.jmod --add-modules java.base,java.xml,hello.world --output jre/
  ```

  我们在`--module-path`参数指定了我们自己的模块`hello.jmod`，然后，在`--add-modules`参数中指定了我们用到的3个模块`java.base`、`java.xml`和`hello.world`，用`,`分隔。最后，在`--output`参数指定输出目录。

  现在，在当前目录下，我们可以找到`jre`目录，这是一个完整的并且带有我们自己`hello.jmod`模块的JRE。试试直接运行这个JRE：

  ```bash
  $ jre/bin/java --module hello.world
  Hello, xml!
  ```

  要分发我们自己的Java应用程序，只需要把这个`jre`目录打个包给对方发过去，对方直接运行上述命令即可，既不用下载安装JDK，也不用知道如何配置我们自己的模块，极大地方便了分发和部署。

- 访问权限

  Java的class访问权限分为public、protected、private和默认的包访问权限。引入模块后，这些访问权限的规则就要稍微做些调整。

  确切地说，class的这些访问权限只在一个模块内有效，模块和模块之间，例如，a模块要访问b模块的某个class，必要条件是b模块明确地导出了可以访问的包。

  举个例子：我们编写的模块`hello.world`用到了模块`java.xml`的一个类`javax.xml.XMLConstants`，我们之所以能直接使用这个类，是因为模块`java.xml`的`module-info.java`中声明了若干导出：

  ```
  module java.xml {
      exports java.xml;
      exports javax.xml.catalog;
      exports javax.xml.datatype;
      ...
  }
  ```

  只有它声明的导出的包，外部代码才被允许访问。换句话说，如果外部代码想要访问我们的`hello.world`模块中的`com.itranswarp.sample.Greeting`类，我们必须将其导出：

  ```
  module hello.world {
      exports com.itranswarp.sample;
  
      requires java.base;
  	requires java.xml;
  }
  ```

  因此，模块进一步隔离了代码的访问权限。



