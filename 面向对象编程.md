#  一、基本概念

面向对象编程：Object-Oriented Programming，简称OOP。是一种通过对象的方式，把现实世界映射到计算机模型的一种编程方法。

基本概念，包括：

- 类
- 实例
- 方法

实现方式，包括：

- 继承
- 多态

Java语言本身提供的机制，包括：

- package
- classpath
- jar



# 二、类与实例

## 2.1 创建类

在Java中，创建一个类，例如，给这个类命名为`Person`，就是定义一个`class`：

```
class Person {
    public String name;
    public int age;
}
```

`public`是用来修饰字段的，它表示这个字段可以被外部访问。

## 2.2 创建实例

 定义了class，只是定义了对象模版，而要根据对象模版创建出真正的对象实例，必须用new操作符。

new操作符可以创建一个实例，然后，我们需要定义一个引用类型的变量来指向这个实例：

```
Person ming = new Person();
```



 **一个Java源文件可以包含多个类的定义，但只能定义一个public类，且public类名必须与文件名一致。如果要定义多个public类，必须拆到多个Java源文件中。**





# 三、面向对象基础

## 3.1 方法

直接把`field`用`public`暴露给外部可能会破坏封装性，直接操作`field`，容易造成逻辑混乱。为了避免外部代码直接去访问`field`，我们可以用`private`修饰`field`，拒绝外部访问：

```
class Person {
    private String name;
    private int age;
}
```

需要使用方法（`method`）来让外部代码可以间接修改`field`：



## 3.2 this变量

在方法内部，可以使用一个隐含的变量`this`，它始终指向当前实例。因此，通过`this.field`就可以访问当前实例的字段。

如果没有命名冲突，可以省略`this`。例如：

```
class Person {
    private String name;

    public String getName() {
        return name; // 相当于this.name
    }
}
```

但是，如果有局部变量和字段重名，那么局部变量优先级更高，就必须加上`this`：

```
class Person {
    private String name;

    public void setName(String name) {
        this.name = name; // 前面的this不可少，少了就变成局部变量name了
    }
}
```



## 3.3 参数

可变参数用`类型...`定义，可变参数相当于数组类型：

```
class Group {
    private String[] names;

    public void setNames(String... names) {
        this.names = names;
    }
}
```

可变参数的意义：

​	如果写成`String[]`类型，调用方需要自己先构造String，而且可以传入null

  而可变参数可以保证无法传入null， 因为传入0个参数时，接受到的实际值是一个空数组而不是null



- 参数绑定

  ```
  public class Main {
      public static void main(String[] args) {
          Person p = new Person();
          String[] fullname = new String[] { "Homer", "Simpson" };
          p.setName(fullname); // 传入fullname数组
          System.out.println(p.getName()); // "Homer Simpson"
          fullname[0] = "Bart"; // fullname数组的第一个元素修改为"Bart"
          System.out.println(p.getName()); // "Homer Simpson"还是"Bart Simpson"?
      }
  }
  
  class Person {
      private String[] name;
  
      public String getName() {
          return this.name[0] + " " + this.name[1];
      }
  
      public void setName(String[] name) {
          this.name = name;
      }
  }
  
  ```

  **引用类型参数的传递，调用方的变量，和接收方的参数变量**，**指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方（因为指向同一个对象嘛）。**





## 3.4 构造方法

构造方法的名称就是类名。构造方法的参数没有限制，在方法内部，也可以编写任意语句。但是，和普通方法相比，构造方法没有返回值（也没有`void`），调用构造方法，必须用`new`操作符。

- 默认构造方法：如果一个类没有定义构造方法，编译器会自动为我们生成一个默认构造方法，它没有参数，也没有执行语句，类似这样：

  ```
  class Person {
      public Person() {
      }
  }
  ```

  如果我们自定义了一个构造方法，那么**，编译器就*不再*自动创建默认构造方法**：

  ```
  public class Main {
      public static void main(String[] args) {
          Person p = new Person(); // 编译错误:找不到这个构造方法
      }
  }
  
  class Person {
      private String name;
      private int age;
  
      public Person(String name, int age) {
          this.name = name;
          this.age = age;
      }
      
      public String getName() {
          return this.name;
      }
  
      public int getAge() {
          return this.age;
      }
  }
  
  ```

  如果既要能使用带参数的构造方法，又想保留不带参数的构造方法，那么只能把两个构造方法都定义出来

  没有在构造方法中初始化字段时，**引用类型的字段默认是`null`，数值类型的字段用默认值，`int`类型默认值是`0`，布尔类型默认值是`false`**

  在Java中，创建对象实例的时候，按照如下顺序进行初始化：

  1. **先初始化字段，例如，`int age = 10;`表示字段初始化为`10`，`double salary;`表示字段默认初始化为`0`，`String name;`表示引用类型字段默认初始化为`null`；**
  2. **执行构造方法的代码进行初始化。**

  因此，构造方法的代码由于后运行，所以，`new Person("Xiao Ming", 12)`的字段值最终由构造方法的代码确定。

  ```
  class Person {
      private String name = "Unamed";
      private int age = 10;
  
      public Person(String name, int age) {
          this.name = name;
          this.age = age;
      }
  }
  ```

- 多级构造方法

  可以定义多个构造方法，在通过`new`操作符调用的时候，编译器通过构造方法的参数数量、位置和类型自动区分：

  ```
  class Person {
      private String name;
      private int age;
  
      public Person(String name, int age) {
          this.name = name;
          this.age = age;
      }
  
      public Person(String name) {
          this.name = name;
          this.age = 12;
      }
  
      public Person() {
      }
  }
  ```

  **一个构造方法可以调用其他构造方法**，这样做的目的是便于代码复用。调用其他构造方法的语法是`this(…)`

  ```
  class Person {
      private String name;
      private int age;
  
      public Person(String name, int age) {
          this.name = name;
          this.age = age;
      }
  
      public Person(String name) {
          this(name, 18); // 调用另一个构造方法Person(String, int)
      }
  
      public Person() {
          this("Unnamed"); // 调用另一个构造方法Person(String)
      }
  }
  ```

## 3.5 方法重载

方法名相同，但各自的参数不同，称为方法重载（`Overload`），注意：**方法重载的返回值类型通常都是相同的。**

方法重载的目的是，功能类似的方法使用同一名字，更容易记住，因此，调用起来更简单。例如，`String`类提供了多个重载方法`indexOf()`，可以查找子串：

- `int indexOf(int ch)`：根据字符的Unicode码查找；
- `int indexOf(String str)`：根据字符串查找；
- `int indexOf(int ch, int fromIndex)`：根据字符查找，但指定起始位置；
- `int indexOf(String str, int fromIndex)`根据字符串查找，但指定起始位置。



## 3.6 继承

Java使用`extends`关键字来实现继承：

```
class Person {
    private String name;
    private int age;

    public String getName() {...}
    public void setName(String name) {...}
    public int getAge() {...}
    public void setAge(int age) {...}
}

class Student extends Person {
    // 不要重复name和age字段/方法,
    // 只需要定义新增score字段/方法:
    private int score;

    public int getScore() { … }
    public void setScore(int score) { … }
}
```

**子类自动获得了父类的所有字段，严禁定义与父类重名的字段！**

在OOP的术语中，我们把`Person`称为**超类（super class），父类（parent class），基类（base class）**，把`Student`称为**子类（subclass），扩展类（extended class**）。

- 继承树

  在Java中，**没有明确写`extends`的类，编译器会自动加上`extends Object`**。所以，任何类，除了`Object`，都会继承自某个类。下图是`Person`、`Student`的继承树：

  ```ascii
  ┌───────────┐
  │  Object   │
  └───────────┘
        ▲
        │
  ┌───────────┐
  │  Person   │
  └───────────┘
        ▲
        │
  ┌───────────┐
  │  Student  │
  └───────────┘
  ```

  Java只允许一个class继承自一个类，因此，一个类有且仅有一个父类。只有`Object`特殊，它没有父类。

- protected

  继承有个特点，就是子类无法访问父类的`private`字段或者`private`方法。例如，`Student`类就无法访问`Person`类的`name`和`age`字段：

  这使得继承的作用被削弱了。为了让子类可以访问父类的字段，我们需要把`private`改为`protected`。用`protected`修饰的字段可以被子类访问：

- super

  `super`关键字表示父类（超类）。子类引用父类的字段时，可以用`super.fieldName`。例如：

  ```
  class Student extends Person {
      public String hello() {
          return "Hello, " + super.name;
      }
  }
  ```

  实际上，这里使用`super.name`，或者`this.name`，或者`name`，效果都是一样的。编译器会自动定位到父类的`name`字段。

  但是，在某些时候，就必须使用`super`

  ```
  public class Main {
      public static void main(String[] args) {
          Student s = new Student("Xiao Ming", 12, 89);
      }
  }
  
  class Person {
      protected String name;
      protected int age;
  
      public Person(String name, int age) {
          this.name = name;
          this.age = age;
      }
  }
  
  class Student extends Person {
      protected int score;
  
      public Student(String name, int age, int score) {
          this.score = score;
      }
  }
  
  ```

  运行上面的代码，会得到一个编译错误，大意是在`Student`的构造方法中，无法调用`Person`的构造方法。

  **这是因为在Java中，任何`class`的构造方法，第一行语句必须是调用父类的构造方法**。如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句`super();`，所以，`Student`类的构造方法实际上是这样：

  ```
  class Student extends Person {
      protected int score;
  
      public Student(String name, int age, int score) {
          super(); // 自动调用父类的构造方法
          this.score = score;
      }
  }
  ```

  但是，`Person`类并没有无参数的构造方法，因此，编译失败。

  解决方法是调用`Person`类存在的某个构造方法。例如：

  ```
  class Student extends Person {
      protected int score;
  
      public Student(String name, int age, int score) {
          super(name, age); // 调用父类的构造方法Person(String, int)
          this.score = score;
      }
  }
  ```

  **如果父类没有默认的构造方法，子类就必须显式调用`super()`并给出参数以便让编译器定位到父类的一个合适的构造方法**。

  **子类*不会继承*任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。**

  - 阻止继承

    正常情况下，只要某个class没有`final`修饰符，那么任何类都可以从该class继承。

    从Java 15开始，允许使用`sealed`修饰class，并通过`permits`明确写出能够从该class继承的子类名称。

    ```
    public sealed class Shape permits Rect, Circle, Triangle {
        ...
    }
    ```

  - 向上转型

    如果一个引用变量的类型是`Student`，那么它可以指向一个`Student`类型的实例：

    ```
    Student s = new Student();
    ```

    如果一个引用类型的变量是`Person`，那么它可以指向一个`Person`类型的实例：

    ```
    Person p = new Person();
    ```

    一个引用类型为`Person`的变量，能否指向`Student`类型的实例

    ```
    Person p = new Student(); 
    ```

    这是因为`Student`继承自`Person`，因此，它拥有`Person`的全部功能。`Person`类型的变量，如果指向`Student`类型的实例，对它进行操作，是没有问题的！

    这种把一个子类类型安全地变为父类类型的赋值，被称为向上转型（upcasting）。

    向上转型实际上是把一个子类型安全地变为更加抽象的父类型：

    ```
    Student s = new Student();
    Person p = s; // upcasting, ok
    Object o1 = p; // upcasting, ok
    Object o2 = s; // upcasting, ok
    ```

  - 向下转型

    和向上转型相反，如果把一个**父类类型强制转型为子类类型**，就是向下转型（downcasting）。例如：

    ```
    Person p1 = new Student(); // upcasting, ok
    Person p2 = new Person();
    Student s1 = (Student) p1; // ok
    Student s2 = (Student) p2; // runtime error! ClassCastException!
    ```

    `Person`类型`p1`实际指向`Student`实例，`Person`类型变量`p2`实际指向`Person`实例。在向下转型的时候，把`p1`转型为`Student`会成功，因为`p1`确实指向`Student`实例，把`p2`转型为`Student`会失败，因为`p2`的实际类型是`Person`，不能把父类变为子类，因为子类功能比父类多，多的功能无法凭空变出来。

    向下转型很可能会失败。失败的时候，Java虚拟机会报`ClassCastException`。

    为了避免向下转型出错，Java提供了`instanceof`操作符，可以先判断一个实例究竟是不是某种类型：

    ```
    Person p = new Person();
    System.out.println(p instanceof Person); // true
    System.out.println(p instanceof Student); // false
    
    Student s = new Student();
    System.out.println(s instanceof Person); // true
    System.out.println(s instanceof Student); // true
    
    Student n = null;
    System.out.println(n instanceof Student); // false
    ```



## 3.7 多态

在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为覆写（Override）。

在`Person`类中，我们定义了`run()`方法：

```
class Person {
    public void run() {
        System.out.println("Person.run");
    }
}
```

在子类`Student`中，覆写这个`run()`方法：

```
class Student extends Person {
    @Override
    public void run() {
        System.out.println("Student.run");
    }
}
```

Override和Overload不同的是，**如果方法签名不同，就是Overload**，Overload方法是一个新方法；如**果方法签名相同，并且返回值也相同，就是`Override`**。

**方法名相同，方法参数相同，但方法返回值不同，也是不同的方法。在Java程序中，出现这种情况，编译器会报错。**

加上`@Override`可以让编译器帮助检查是否进行了正确的覆写。希望进行覆写，但是不小心写错了方法签名，编译器会报错。



一个实际类型为`Student`，引用类型为`Person`的变量，调用其`run()`方法，**调用的是`Student`的`run()`方法**

Java的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型。

**多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法**。例如：

```
Person p = new Student();
p.run(); // 无法确定运行时究竟调用哪个run()方法
```

多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。

- 覆写Object方法

  因为所有的`class`最终都继承自`Object`，而`Object`定义了几个重要的方法：

  - `toString()`：把instance输出为`String`；
  - `equals()`：判断两个instance是否逻辑相等；
  - `hashCode()`：计算一个instance的哈希值。

  在必要的情况下，我们可以覆写`Object`的这几个方法

  ```
  class Person {
      ...
      // 显示更有意义的字符串:
      @Override
      public String toString() {
          return "Person:name=" + name;
      }
  
      // 比较是否相等:
      @Override
      public boolean equals(Object o) {
          // 当且仅当o为Person类型:
          if (o instanceof Person) {
              Person p = (Person) o;
              // 并且name字段相同时，返回true:
              return this.name.equals(p.name);
          }
          return false;
      }
  
      // 计算hash:
      @Override
      public int hashCode() {
          return this.name.hashCode();
      }
  }
  ```

  在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过`super`来调用。

  ```
  class Person {
      protected String name;
      public String hello() {
          return "Hello, " + name;
      }
  }
  
  class Student extends Person {
      @Override
      public String hello() {
          // 调用父类的hello()方法:
          return super.hello() + "!";
      }
  }
  ```

- final

  继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为`final`。用`final`修饰的方法不能被`Override`：

  ```
  class Person {
      protected String name;
      public final String hello() {
          return "Hello, " + name;
      }
  }
  
  class Student extends Person {
      // compile error: 不允许覆写
      @Override
      public String hello() {
      }
  }
  ```

  如果一个类不希望任何其他类继承自它，那么可以把这个类本身标记为`final`。用`final`修饰的类不能被继承：

  ```
  final class Person {
      protected String name;
  }
  
  // compile error: 不允许继承自Person
  class Student extends Person {
  }
  ```

  对于一个类的实例字段，同样可以用`final`修饰。用`final`修饰的字段在初始化后不能被修改。例如：

  ```
  class Person {
      public final String name = "Unamed";
  }
  ```
  
  可以在构造方法中初始化final字段：
  
  ```
  class Person {
      public final String name;
      public Person(String name) {
          this.name = name;
      }
  }
  ```
  
  这种方法更为常用，因为可以保证实例一旦创建，其`final`字段就不可修改。

## 3.8 抽象类

如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法：

```
class Person {
    public abstract void run();
}
```

如果一个`class`定义了方法，但没有具体执行代码，这个方法就是抽象方法，抽象方法用`abstract`修饰。

因为无法执行抽象方法，因此这个类也必须申明为抽象类（abstract class）。

使用`abstract`修饰的类就是抽象类。我们无法实例化一个抽象类：

```
Person p = new Person(); // 编译错误
```

因为抽象类本身被设计成只能用于被继承，因此，**抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错**。因此，抽象方法实际上相当于定义了“规范”。

- 面向抽象编程

  当我们定义了抽象类`Person`，以及具体的`Student`、`Teacher`子类的时候，我们可以通过抽象类`Person`类型去引用具体的子类的实例：

  ```
  Person s = new Student();
  Person t = new Teacher();
  ```

  这种引用抽象类的好处在于，我们对其进行方法调用，并不关心`Person`类型变量的具体子类型：

  ```
  // 不关心Person变量的具体子类型:
  s.run();
  t.run();
  ```

  同样的代码，如果引用的是一个新的子类，我们仍然不关心具体类型：

  ```
  // 同样不关心新的子类是如何实现run()方法的：
  Person e = new Employee();
  e.run();
  ```

  这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。

  面向抽象编程的本质就是：

  - 上层代码只定义规范（例如：`abstract class Person`）；
  - 不需要子类就可以实现业务逻辑（正常编译）；
  - 具体的业务逻辑由不同的子类实现，调用者并不关心。

## 3.9 接口

在抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力。

如果一个抽象类没有字段，所有方法全部都是抽象方法：

```
abstract class Person {
    public abstract void run();
    public abstract String getName();
}
```

就可以把该抽象类改写为接口：`interface`

在Java中，使用`interface`可以声明一个接口：

```
interface Person {
    void run();
    String getName();
}
```

所谓`interface`，**就是比抽象类还要抽象的纯抽象接口**，因为它连字段都不能有。因为接口定义的所有方法默认都是`public abstract`的，所以这两个修饰符不需要写出来（写不写效果都一样）。

当一个具体的`class`去实现一个`interface`时，需要使用`implements`关键字

```
class Student implements Person {
    private String name;

    public Student(String name) {
        this.name = name;
    }

    @Override
    public void run() {
        System.out.println(this.name + " run");
    }

    @Override
    public String getName() {
        return this.name;
    }
}
```

在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个`interface`

```
class Student implements Person, Hello { // 实现了两个interface
    ...
}
```

抽象类和接口的对比如下：

|            | abstract class       | interface                   |
| :--------- | :------------------- | :-------------------------- |
| 继承       | 只能extends一个class | 可以implements多个interface |
| 字段       | 可以定义实例字段     | 不能定义实例字段            |
| 抽象方法   | 可以定义抽象方法     | 可以定义抽象方法            |
| 非抽象方法 | 可以定义非抽象方法   | 可以定义default方法         |

一个`interface`可以继承自另一个`interface`。`interface`继承自`interface`使用`extends`，它相当于扩展了接口的方法。例如：

```
interface Hello {
    void hello();
}

interface Person extends Hello {
    void run();
    String getName();
```