# Java

## 1.简介

- 应用最广泛、基于JVM虚拟机的跨平台语言，一次编写，到处运行；

- 介于解释型和编译型语言之间，将代码编译成一种“字节码”，针对不同平台编写虚拟机，不同平台的虚拟机负责加载字节码并执行，这样就实现了“一次编写，到处运行”的效果

- 内置垃圾收集，不必考虑内存管理

- 开源社区支持，良好的生态

- Java版本（三者属于包含关系）：

  - Java EE：Enterprise Edition

  - Java SE：Standard Edition

  - Java ME：Micro Edition

    Java SE是整个Java平台的核心，而Java EE是进一步学习Web应用所必须的。我们熟悉的Spring等框架都是Java EE开源生态系统的一部分。不幸的是，Java ME从来没有真正流行起来，反而是Android开发成为了移动平台的标准之一，因此，没有特殊需求，不建议学习Java ME



## 2.名词解释

- JDK：Java Development Kit            JDK除了包含JRE，还提供了编译器、调试器等开发工具。
- JRE：Java Runtime Environment   运行Java字节码的虚拟机。
- JSR规范：Java Specification Request   SUN公司定义的JSR规范，凡是想给Java平台加一个功能，比如说访问数据库的功能，要先创建一个JSR规范，定义好接口，这样，各个数据库厂商都按照规范写出Java驱动程序，开发者就不用担心自己写的数据库代码在MySQL上能跑，却不能跑在PostgreSQL上。
- JCP组织：Java Community Process    JSR是一系列的规范，从JVM的内存模型到Web程序接口，全部都标准化了。而负责审核JSR的组织就是JCP
- RI：Reference Implementation
- TCK：Technology Compatibility Kit





## 3.语法

- `public static void main(String[] args)`是Java程序的固定入口方法，Java程序总是从`main`方法开始执行。缩进不是必须的
- 代码保存为文件时，文件名必须是`类名.java`，而且文件名也要注意大小写，因为要和我们定义的类名完全保持一致。
- **一个Java源码只能定义一个`public`类型的class，并且class名称和文件名要完全一致**；
- `public`是访问修饰符，表示该`class`是公开的，不**写`public`，也能正确编译，但是这个类将无法从命令行执行**。
- 在`class`内部，可以定义若干方法（method），Java入口程序规定的方法必须是静态方法，方法名必须为`main`，括号内的参数必须是String数组。
- 方法名也有命名规则，命名和`class`一样，但是首字母小写：







### 3.1编译

Java源码本质上是一个文本文件，我们需要先用`javac`把`Hello.java`编译成字节码文件`Hello.class`，然后，用`java`命令执行这个字节码文件：

```ascii
┌──────────────────┐
│    Hello.java    │◀── source code
└──────────────────┘
          │ compile
          ▼
┌──────────────────┐
│   Hello.class    │◀── byte code
└──────────────────┘
          │ execute
          ▼
┌──────────────────┐
│    Run on JVM    │
└──────────────────┘
```

因此，可执行文件`javac`是编译器，而可执行文件`java`就是虚拟机。





## 4.数据类型

### 4.1 基本数据类型

- 整数类型：byte（1字节），short（2），int（4），long（8）

对于整型类型，**Java只定义了带符号的整型**，几种整形写法：

```
public class Main {
    public static void main(String[] args) {
        int i = 2147483647;
        int i2 = -2147483648;
        int i3 = 2_000_000_000; // 加下划线更容易识别
        int i4 = 0xff0000; // 十六进制表示的16711680
        int i5 = 0b1000000000; // 二进制表示的512
        long l = 9000000000000000000L; // long型的结尾需要加L
    }
}
```



- 浮点数类型：float（4），double（8)

  ```
  float f1 = 3.14f;
  float f2 = 3.14e38f; // 科学计数法表示的3.14x10^38
  double d = 1.79e308;
  double d2 = -1.79e308;
  double d3 = 4.9e-324; // 科学计数法表示的4.9x10^-324
  
  对于float 类型，需要加上f后缀
  ```

  

- 字符类型：char（2）

  ```
  public class Main {
      public static void main(String[] args) {
          char a = 'A';
          char zh = '中';
          System.out.println(a);
          System.out.println(zh);
      }
  }
  ```

  Java的`char`类型除了可表示标准的ASCII外，还可以表示一个Unicode字符，使用单引号`'`，且仅有一个字符，要和双引号`"`的字符串类型区分开

  

- 布尔类型：boolean（理论上存储只需1bit，但是通常JVM内部会表示为4字节整数）



### 4.2 引用类型

除了基本类型，其他都是引用类型

- String 字符串：类似于C语言的指针，它内部存储一个“地址”，指向某个对象在内存的位置

  ```
  String s = "hello";
  ```

- 常量：定义变量的时候，如果加上`final`修饰符，这个变量就变成了常量（根据习惯，常量名通常全部大写。）

  ```
  final double PI = 3.14; // PI是一个常量
  double r = 5.0;
  double area = PI * r * r;
  PI = 300; // compile error!
  ```

  

- var 关键字：如果想省略变量类型，可以使用`var`关键字（类似 C++中的auto）

  ```
  var sb = new StringBuilder();
  ```






### 4.3 运算

- 整数的数值表示不但是精确的，而且整数运算永远是精确的，即使是除法也是精确的，因为两个整数相除只能得到结果的整数部分：

  ```
  int x = 12345 / 67; // 184
  ```

- 求余运算使用`%`：

  ```
  int y = 12345 % 67; // 12345÷67的余数是17
  ```

- 溢出：整数由于存在范围限制，如果计算结果超出了范围，就会产生溢出，而溢出*不会出错*，却会得到一个奇怪的结果

  ```
  public class Main {
      public static void main(String[] args) {
          int x = 2147483640;
          int y = 15;
          int sum = x + y;
          System.out.println(sum); // -2147483641
      }
  }
  ```

- 移位运算：可以对整数进行移位运算。对整数`7`左移1位将得到整数`14`，左移两位将得到整数`28`：

  ```
  int n = 7;       // 00000000 00000000 00000000 00000111 = 7
  int a = n << 1;  // 00000000 00000000 00000000 00001110 = 14
  int b = n << 2;  // 00000000 00000000 00000000 00011100 = 28
  int c = n << 28; // 01110000 00000000 00000000 00000000 = 1879048192
  int d = n << 29; // 11100000 00000000 00000000 00000000 = -536870912
  ```

  类似的，对整数28进行右移，结果如下：

  ```
  int n = 7;       // 00000000 00000000 00000000 00000111 = 7
  int a = n >> 1;  // 00000000 00000000 00000000 00000011 = 3
  int b = n >> 2;  // 00000000 00000000 00000000 00000001 = 1
  int c = n >> 3;  // 00000000 00000000 00000000 00000000 = 0
  ```

  **如果对一个负数进行右移，最高位的`1`不动，结果仍然是一个负数：**

  ```
  int n = -536870912;
  int a = n >> 1;  // 11110000 00000000 00000000 00000000 = -268435456
  int b = n >> 2;  // 11111000 00000000 00000000 00000000 = -134217728
  int c = n >> 28; // 11111111 11111111 11111111 11111110 = -2
  int d = n >> 29; // 11111111 11111111 11111111 11111111 = -1
  ```

  还有一种无符号的右移运算，使用`>>>`，它的特点是不管符号位，右移后高位总是补`0`，因此，对一个负数进行`>>>`右移，它会变成正数，原因是最高位的`1`变成了`0`：

  ```
  int n = -536870912;
  int a = n >>> 1;  // 01110000 00000000 00000000 00000000 = 1879048192
  int b = n >>> 2;  // 00111000 00000000 00000000 00000000 = 939524096
  int c = n >>> 29; // 00000000 00000000 00000000 00000111 = 7
  int d = n >>> 31; // 00000000 00000000 00000000 00000001 = 1
  ```

  **对`byte`和`short`类型进行移位时，会首先转换为`int`再进行位移**。

  仔细观察可发现，**左移实际上就是不断地×2，右移实际上就是不断地÷2**。

- 位运算

  与运算的规则是，必须两个数同时为`1`，结果才为`1`：

  ```
  n = 0 & 0; // 0
  n = 0 & 1; // 0
  n = 1 & 0; // 0
  n = 1 & 1; // 1
  ```

  或运算的规则是，只要任意一个为`1`，结果就为`1`：

  ```
  n = 0 | 0; // 0
  n = 0 | 1; // 1
  n = 1 | 0; // 1
  n = 1 | 1; // 1
  ```

  非运算的规则是，`0`和`1`互换：

  ```
  n = ~0; // 1
  n = ~1; // 0
  ```

  异或运算的规则是，如果两个数不同，结果为`1`，否则为`0`：

  ```
  n = 0 ^ 0; // 0
  n = 0 ^ 1; // 1
  n = 1 ^ 0; // 1
  n = 1 ^ 1; // 0
  ```

  对两个整数进行位运算，实际上就是按位对齐，然后依次对每一位进行运算。例如：

  ```
  public class Main {
      public static void main(String[] args) {
          int i = 167776589; // 00001010 00000000 00010001 01001101
          int n = 167776512; // 00001010 00000000 00010001 00000000
          System.out.println(i & n); // 167776512
      }
  }
  ```

- 强制转型

  ```
  int i = 12345;
  short s = (short) i; // 12345
  ```

- 浮点运算：浮点数运算和整数运算相比，只能进行加减乘除这些数值计算，不能做位运算和移位运算。

  浮点数`0.1`在计算机中就无法精确表示，因为十进制的`0.1`换算成二进制是一个无限循环小数，很显然，无论使用`float`还是`double`，都只能存储一个`0.1`的近似值。但是，`0.5`这个浮点数又可以精确地表示。

  由于浮点数存在运算误差，所以比较两个浮点数是否相等常常会出现错误的结果。正**确的比较方法是判断两个浮点数之差的绝对值是否小于一个很小的数**：

  ```
  // 比较x和y是否相等，先计算其差的绝对值:
  double r = Math.abs(x - y);
  // 再判断绝对值是否足够小:
  if (r < 0.00001) {
      // 可以认为相等
  } else {
      // 不相等
  }
  ```

  如果参与运算的两个数其中一个是整型，那么整型可以自动提升到浮点型：

  需要特别注意，在一个复杂的四则运算中，两个整数的运算不会出现自动提升的情况。例如：

  ```
  double d = 1.2 + 24 / 5; // 5.2
  ```

- 三元运算符：Java还提供一个三元运算符`b ? x : y`，它根据第一个布尔表达式的结果，分别返回后续两个表达式之一的计算结果

  ```
  public class Main {
      public static void main(String[] args) {
          int n = -100;
          int x = n >= 0 ? n : -n;
          System.out.println(x);
      }
  }
  ```

### 4.4 字符与字符串

在Java中，**字符和字符串是两个不同的类型。**

#### 字符

字符类型`char`是基本数据类型，它是`character`的缩写。一个`char`保存一个Unicode字符：

```
char c1 = 'A';
char c2 = '中';
```

因为Java在内存中总是使用Unicode表示字符，所以，一个英文字符和一个中文字符都用一个`char`类型表示，它们都占用两个字节。要显示一个字符的Unicode编码，只需将`char`类型直接赋值给`int`类型即可

```
int n1 = 'A'; // 字母“A”的Unicodde编码是65
int n2 = '中'; // 汉字“中”的Unicode编码是20013
```

还可以直接用转义字符`\u`+Unicode编码来表示一个字符：

```
// 注意是十六进制:
char c3 = '\u0041'; // 'A'，因为十六进制0041 = 十进制65
char c4 = '\u4e2d'; // '中'，因为十六进制4e2d = 十进制20013
```



#### 字符串

- 字符串类型`String`是引用类型，我们用双引号`"..."`表示字符串。一个字符串可以存储0个到任意个字符：

```
String s = ""; // 空字符串，包含0个字符
String s1 = "A"; // 包含一个字符
String s2 = "ABC"; // 包含3个字符
String s3 = "中文 ABC"; // 包含6个字符，其中有一个空格
```

- 转义字符`\`：

```
String s = "abc\"xyz"; // 包含7个字符: a, b, c, ", x, y, z
```

因为`\`是转义字符，所以，两个`\\`表示一个`\`字符：

```
String s = "abc\\xyz"; // 包含7个字符: a, b, c, \, x, y, z
```

常见的转义字符包括：

- `\"` 表示字符`"`
- `\'` 表示字符`'`
- `\\` 表示字符`\`
- `\n` 表示换行符
- `\r` 表示回车符
- `\t` 表示Tab
- `\u####` 表示一个Unicode编码的字符

```
String s = "ABC\n\u4e2d\u6587"; // 包含6个字符: A, B, C, 换行符, 中, 文
```

如果用`+`连接字符串和其他数据类型，会将其他数据类型先自动转型为字符串，再连接

- 从Java 13开始，字符串可以用`"""..."""`表示多行字符串

```
public class Main {
    public static void main(String[] args) {
        String s = """
                   SELECT * FROM
                     users
                   WHERE id > 100
                   ORDER BY name DESC
                   """;
        System.out.println(s);
    }
}
```

- 不可变特性：Java的字符串除了是一个引用类型外，还有个重要特点，就是字符串不可变。

  字符串的不可变是指字符串内容不可变。至于变量，可以一会指向字符串`"hello"`，一会指向字符串`"world"`。

- 空值null

  引用类型的变量可以指向一个空值`null`，它表示不存在，即该变量不指向任何对象。例如：

  ```
  String s1 = null; // s1是null
  String s2 = s1; // s2也是null
  String s3 = ""; // s3指向空字符串，不是null
  ```



### 4.5 数据类型

Java的数组有几个特点：

- 数组所有元素初始化为默认值，整型都是`0`，浮点型是`0.0`，布尔型是`false`；
- 数组一旦创建后，大小就不可改变。

要访问数组中的某一个元素，需要使用索引。数组索引从`0`开始，例如，5个元素的数组，索引范围是`0`~`4`。

可以修改数组中的某一个元素，使用赋值语句，例如，`ns[1] = 79;`。

可以用`数组变量.length`获取数组大小：

```
public class Main {
    public static void main(String[] args) {
        // 5位同学的成绩:
        int[] ns = new int[5];
        System.out.println(ns.length); // 5
    }
}
```

也可以在定义数组时直接指定初始化的元素，这样就不必写出数组大小，而是由编译器自动推算数组大小。例如：

```
public class Main {
    public static void main(String[] args) {
        // 5位同学的成绩:
        int[] ns = new int[] { 68, 79, 91, 85, 62 };
        System.out.println(ns.length); // 编译器自动推算数组大小为5
    }
}

```

还可以进一步简写为：

```
int[] ns = { 68, 79, 91, 85, 62 };
```

**注意数组是引用类型，并且数组大小不可变**

```
public class Main {
    public static void main(String[] args) {
        // 5位同学的成绩:
        int[] ns;
        ns = new int[] { 68, 79, 91, 85, 62 };
        System.out.println(ns.length); // 5
        ns = new int[] { 1, 2, 3 };
        System.out.println(ns.length); // 3
    }
}
```

数组大小变了吗？看上去好像是变了，但其实根本没变。

对于数组`ns`来说，执行`ns = new int[] { 68, 79, 91, 85, 62 };`时，它指向一个5个元素的数组：

```ascii
     ns
      │
      ▼
┌───┬───┬───┬───┬───┬───┬───┐
│   │68 │79 │91 │85 │62 │   │
└───┴───┴───┴───┴───┴───┴───┘
```

执行`ns = new int[] { 1, 2, 3 };`时，它指向一个*新的*3个元素的数组：

```ascii
     ns ──────────────────────┐
                              │
                              ▼
┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐
│   │68 │79 │91 │85 │62 │   │ 1 │ 2 │ 3 │   │
└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘
```

但是，原有的5个元素的数组并没有改变，只是无法通过变量`ns`引用到它们而已。

### 字符串数组

如果数组元素不是基本类型，而是一个引用类型，那么，修改数组元素会有哪些不同？

字符串是引用类型，因此我们先定义一个字符串数组：

```
String[] names = {
    "ABC", "XYZ", "zoo"
};
```

对于`String[]`类型的数组变量`names`，它实际上包含3个元素，但每个元素都指向某个字符串对象：

```ascii
          ┌─────────────────────────┐
    names │   ┌─────────────────────┼───────────┐
      │   │   │                     │           │
      ▼   │   │                     ▼           ▼
┌───┬───┬─┴─┬─┴─┬───┬───────┬───┬───────┬───┬───────┬───┐
│   │░░░│░░░│░░░│   │ "ABC" │   │ "XYZ" │   │ "zoo" │   │
└───┴─┬─┴───┴───┴───┴───────┴───┴───────┴───┴───────┴───┘
      │                 ▲
      └─────────────────┘
```

对`names[1]`进行赋值，例如`names[1] = "cat";`，效果如下：

```ascii
          ┌─────────────────────────────────────────────────┐
    names │   ┌─────────────────────────────────┐           │
      │   │   │                                 │           │
      ▼   │   │                                 ▼           ▼
┌───┬───┬─┴─┬─┴─┬───┬───────┬───┬───────┬───┬───────┬───┬───────┬───┐
│   │░░░│░░░│░░░│   │ "ABC" │   │ "XYZ" │   │ "zoo" │   │ "cat" │   │
└───┴─┬─┴───┴───┴───┴───────┴───┴───────┴───┴───────┴───┴───────┴───┘
      │                 ▲
      └─────────────────┘
```

这里注意到原来`names[1]`指向的字符串`"XYZ"`并没有改变，仅仅是将`names[1]`的引用从指向`"XYZ"`改成了指向`"cat"`，其结果是字符串`"XYZ"`再也无法通过`names[1]`访问到了。







## 5.数组操作

### 5.1数组操作

- 遍历

```
# 下标遍历

public class Main {
    public static void main(String[] args) {
        int[] ns = { 1, 4, 9, 16, 25 };
        for (int i=0; i<ns.length; i++) {
            int n = ns[i];
            System.out.println(n);
        }
    }
}
```

```
# for each 遍历

public class Main {
    public static void main(String[] args) {
        int[] ns = { 1, 4, 9, 16, 25 };
        for (int n : ns) {
            System.out.println(n);
        }
    }
}
```

- 打印数组内容

  直接打印数组变量，得到的是数组在JVM中的引用地址：

  ```
  int[] ns = { 1, 1, 2, 3, 5, 8 };
  System.out.println(ns); // 类似 [I@7852e922
  ```

  这并没有什么意义，因为我们希望打印的数组的元素内容。因此，使用`for each`循环来打印它：

  ```
  int[] ns = { 1, 1, 2, 3, 5, 8 };
  for (int n : ns) {
      System.out.print(n + ", ");
  }
  ```

  Java标准库提供了`Arrays.toString()`，可以快速打印数组内容

  ```\
  import java.util.Arrays;
  
  public class Main {
      public static void main(String[] args) {
          int[] ns = { 1, 1, 2, 3, 5, 8 };
          System.out.println(Arrays.toString(ns));
      }
  }
  ```

- 排序：Java内置排序功能，调用`Arrays.sort()`即可实现排序

  ```
  import java.util.Arrays;
  
  public class Main {
      public static void main(String[] args) {
          int[] ns = { 28, 12, 89, 73, 65, 18, 96, 50, 8, 36 };
          Arrays.sort(ns);
          System.out.println(Arrays.toString(ns));
      }
  }
  ```

  **对数组排序实际上修改了数组本身**。例如，排序前的数组是：

  ```
  int[] ns = { 9, 3, 6, 5 };
  ```

  在内存中，这个整型数组表示如下：

  ```ascii
        ┌───┬───┬───┬───┐
  ns───▶│ 9 │ 3 │ 6 │ 5 │
        └───┴───┴───┴───┘
  ```

  当我们调用`Arrays.sort(ns);`后，这个整型数组在内存中变为：

  ```ascii
        ┌───┬───┬───┬───┐
  ns───▶│ 3 │ 5 │ 6 │ 9 │
        └───┴───┴───┴───┘
  ```

  即变量`ns`指向的数组内容已经被改变了。

  如果对一个字符串数组进行排序，例如：

  ```
  String[] ns = { "banana", "apple", "pear" };
  ```

  排序前，这个数组在内存中表示如下：

  ```ascii
                     ┌──────────────────────────────────┐
                 ┌───┼──────────────────────┐           │
                 │   │                      ▼           ▼
           ┌───┬─┴─┬─┴─┬───┬────────┬───┬───────┬───┬──────┬───┐
  ns ─────▶│░░░│░░░│░░░│   │"banana"│   │"apple"│   │"pear"│   │
           └─┬─┴───┴───┴───┴────────┴───┴───────┴───┴──────┴───┘
             │                 ▲
             └─────────────────┘
  ```

  调用`Arrays.sort(ns);`排序后，这个数组在内存中表示如下：

  ```ascii
                     ┌──────────────────────────────────┐
                 ┌───┼──────────┐                       │
                 │   │          ▼                       ▼
           ┌───┬─┴─┬─┴─┬───┬────────┬───┬───────┬───┬──────┬───┐
  ns ─────▶│░░░│░░░│░░░│   │"banana"│   │"apple"│   │"pear"│   │
           └─┬─┴───┴───┴───┴────────┴───┴───────┴───┴──────┴───┘
             │                              ▲
             └──────────────────────────────┘
  ```

  原来的3个字符串在内存中均没有任何变化，但是`ns`数组的每个元素指向变化了。

  

  

 ### 5.2二维数组

二维数组就是数组的数组。定义一个二维数组如下：

```
public class Main {
    public static void main(String[] args) {
        int[][] ns = {
            { 1, 2, 3, 4 },
            { 5, 6, 7, 8 },
            { 9, 10, 11, 12 }
        };
        System.out.println(ns.length); // 3
    }
}
```

**二维数组的每个数组元素的长度并不要求相同**，例如，可以这么定义`ns`数组：

```
int[][] ns = {
    { 1, 2, 3, 4 },
    { 5, 6 },
    { 7, 8, 9 }
};
```

打印二维数组可以用Java标准库的 `Arrays.deepToString()`：

```
import java.util.Arrays;

public class Main {
    public static void main(String[] args) {
        int[][] ns = {
            { 1, 2, 3, 4 },
            { 5, 6, 7, 8 },
            { 9, 10, 11, 12 }
        };
        System.out.println(Arrays.deepToString(ns));
    }
}
```





## 6.命令行操作

Java程序的入口是`main`方法，而`main`方法可以接受一个命令行参数，它是一个`String[]`数组。

这个命令行参数由JVM接收用户输入并传给`main`方法：

``` 
public class Main {
    public static void main(String[] args) {
        for (String arg : args) {
            System.out.println(arg);
        }
    }
}
```

我们可以利用接收到的命令行参数，根据不同的参数执行不同的代码。例如，实现一个`-version`参数，打印程序版本号：

```
public class Main {
    public static void main(String[] args) {
        for (String arg : args) {
            if ("-version".equals(arg)) {
                System.out.println("v 1.0");
                break;
            }
        }
    }
}
```